%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{Boulder Dash}
\date{Sep 13, 2019}
\release{1.0}
\author{İsmail Tapan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Boulder dash is a well-known video game. In this project, i replicated the game.

This project contains two main program
\begin{itemize}
\item {} 
1- Game

\item {} 
2- Level Editor/Creator

\end{itemize}

\begin{DUlineblock}{0em}
\item[] To build the game, type \sphinxcode{\sphinxupquote{make}} in command line on root folder.
\item[] To build the level editor, type \sphinxcode{\sphinxupquote{make level}} in command line on root folder.
\item[] 
\item[] After building,
\item[] To open the game, run \sphinxcode{\sphinxupquote{run-game.sh}}.
\item[] To open the level editor, run \sphinxcode{\sphinxupquote{run-level.sh}}.
\end{DUlineblock}


\chapter{Requirements}
\label{\detokenize{index:requirements}}\begin{itemize}
\item {} 
Make

\item {} 
Gcc

\end{itemize}

You don’t need any other file or program to run this code, you don’t need any library installed on your sistem.


\chapter{Better Understanding Of Source}
\label{\detokenize{index:better-understanding-of-source}}

\section{Controls, Game and Player Updates}
\label{\detokenize{player:controls-game-and-player-updates}}\label{\detokenize{player::doc}}

\subsection{Controls and Player}
\label{\detokenize{player:controls-and-player}}
Player updates within a period. It moves only when it updates, but program takes
events all the time. If player is not moving and player presses a key, the player
will move even when the user releases the key before update. It helps to play one
block a time each time. But if the player is moving and user releases a key before
the update player won’t move. It improves smoothness on move.
Move events handling in two steps,
\begin{itemize}
\item {} 
Finding the keys user presses

\item {} 
Take players move direction from these keys

\end{itemize}

If user presses up and down in the same time, player won’t move. If user presses up
and down and left, player will move left.


\subsection{Game Updates}
\label{\detokenize{player:game-updates}}
Everything depends on time, there is no delay or fixed fps. Everytime the one loop ends,
i took the time difference between start and end and adding the result to timer variable.
Every situation except event handling has its own period and its controlled by timer.
Events are always handled independent from timer.


\subsubsection{Animations}
\label{\detokenize{player:animations}}
Animations update faster than the game events. There is nothing much.


\subsubsection{Rocks}
\label{\detokenize{player:rocks}}
Rocks update when game updates. Rocks contains two situation, active and deactive.
If a rock is deactive and it is capable to fall, it becomes active.
If a rock is active and it is capable to fall, it falls, if it’s not, it becomes deactive.
When player go under a deactive rock, rock won’t fall and won’t be activated.
Rocks are only animated when they are active.
Diamonds acts like rocks but they are always animated.


\subsubsection{Mobs}
\label{\detokenize{player:mobs}}
When game updates, every mob in map tries to move in its own way.


\section{Mobs}
\label{\detokenize{mobs:mobs}}\label{\detokenize{mobs::doc}}

\subsection{Spider}
\label{\detokenize{mobs:spider}}
Works recursive, if it can go left it goes over and over, if it can’t go it changes
its direction and tries again. For handling endless loops, if all sides are closed,
function returns.
When it dies it only converts dirts to diamond.


\subsection{Monster}
\label{\detokenize{mobs:monster}}
It looks to player position and tries to move. If player stands diagonal to monster,
monster tries both to way to move.
When it dies it converts all blocks around except player and border to diamond.


\section{Scenes}
\label{\detokenize{scenes:scenes}}\label{\detokenize{scenes::doc}}

\subsection{Intro}
\label{\detokenize{scenes:intro}}
There is nothing much. There are two sprites, cursor and background. When window size changes,
background streches, cursors’ position is relative to window’s size so it does not change.

The game has 2 themes, so there is a change theme option.


\subsection{Pre-Stage}
\label{\detokenize{scenes:pre-stage}}
This is shown to user everytime before the stage, it shows current level, score
and health. All components are relative to window size.


\subsection{Stage}
\label{\detokenize{scenes:stage}}
This is the only complex scene in game. It is the game session. It contains two main
component sets, map and HUD. HUD is simple, on left there is a bar says how much diamond
you need to collect to open the door, on right there are score bar and time bar shows
you how much time left, on middle of the top there is a pause button and thats it.
The map part shows a part of the all map near to player, every block takes 30px30p space,
this is not changing, block sizes are fixed, when you change window size, it only effects
how much block is shown on screen. Everytime a stage starts, it initializates audio device
and sound and closing them when stage ends.


\subsection{End}
\label{\detokenize{scenes:end}}
It says gameover and shows your final score. If you passed all levels it’s green,
if you failed it’s red and thats it.


\section{Audio}
\label{\detokenize{audio:audio}}\label{\detokenize{audio::doc}}
I used SDL\_Audio for this project, the reason for i used this instead of SDL\_Mixer
is i wanted to build this project with just using core sdl library.

I didn’t use any sound file, i stored some frequencies equivalent to some notes in order to
make a melody. SDL\_Audio does not have a function that allows us to play with the speed,
so i’m using different system. Notes are changing with time, when i change the changing rate,
i can change the speed.
A sound is basicly just a sine wave, so as a callback funtion for audio device, i wrote a callback
function which basicly does a triangle shaped sine wave.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{synth\PYGZus{}triangle\PYGZus{}callback}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{data}\PYG{p}{,} \PYG{n}{Uint8} \PYG{o}{*}\PYG{n}{buffer}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{length}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Sound} \PYG{o}{*}\PYG{n}{sound} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Sound} \PYG{o}{*}\PYG{p}{)}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{length}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{buffer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{asin}\PYG{p}{(}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{M\PYGZus{}PI}\PYG{o}{*}\PYG{n}{sound}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{samplePos} \PYG{o}{/} \PYG{n}{sound}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{samplesPerSine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{M\PYGZus{}PI}\PYG{o}{*}\PYG{n}{AMPLITUDE}\PYG{p}{;}
        \PYG{o}{+}\PYG{o}{+}\PYG{n}{sound}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{samplePos}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

It takes samples from a triangle shaped sine wave and pushes to the audio device buffer.

I store all sound information in a structure called Sound.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct}\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{double} \PYG{n}{sampleFreq}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{samplesPerSine}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{samplePos}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{notePos}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{speed}\PYG{p}{;}
  \PYG{n}{Note} \PYG{n}{melody}\PYG{p}{[}\PYG{n}{MAX\PYGZus{}MELODY\PYGZus{}LEN}\PYG{p}{]}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{melodyLen}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{active}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{n}{Sound}\PYG{p}{;}
\end{sphinxVerbatim}

The first 3 variables are about making a sound, the other variables are about the melody.
\sphinxcode{\sphinxupquote{int active}} is just for making the sound more realistic, when the current note changes,
active becomes 0, and when it is 0 it does not make a sound. It really helps to get rid of
the continuous buzzer-like sound.


\section{Textures and Rendering}
\label{\detokenize{textures:textures-and-rendering}}\label{\detokenize{textures::doc}}
Textures are global variables, they loads when \sphinxcode{\sphinxupquote{load\_textures(...)}} called
and stays in memory until \sphinxcode{\sphinxupquote{free\_textures()}} called. There are two themes,
there is a global variable called \sphinxcode{\sphinxupquote{theme}} stores current theme. When
\sphinxcode{\sphinxupquote{load\_textures(...)}} called, it loads current themes files as textures.
Core sdl does not capable of font rendering. So i used prepared assets for text and
wrote custom rendering function for numbers. It turns numbers to string, then iterates
and pair each character a part of digits texture.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{render\PYGZus{}number}\PYG{p}{(}\PYG{n}{SDL\PYGZus{}Renderer} \PYG{o}{*} \PYG{n}{renderer}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{num}\PYG{p}{,} \PYG{n}{Point} \PYG{n}{c}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{size}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{len}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,}\PYG{n}{w}\PYG{p}{,}\PYG{n}{h}\PYG{p}{;}
  \PYG{n}{SDL\PYGZus{}Rect} \PYG{n}{source}\PYG{p}{,}\PYG{n}{dest}\PYG{p}{;}
  \PYG{k+kt}{char} \PYG{n}{text}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{SDL\PYGZus{}QueryTexture}\PYG{p}{(}\PYG{n}{tDigits}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{w}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}0*d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{len}\PYG{p}{,}\PYG{n}{num}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{len}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{dest}\PYG{p}{.}\PYG{n}{h}\PYG{o}{=}\PYG{n}{size}\PYG{p}{;}
    \PYG{n}{dest}\PYG{p}{.}\PYG{n}{w}\PYG{o}{=}\PYG{n}{size}\PYG{p}{;}
    \PYG{n}{dest}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{c}\PYG{p}{.}\PYG{n}{x}\PYG{o}{+}\PYG{n}{i}\PYG{o}{*}\PYG{n}{size}\PYG{p}{;}
    \PYG{n}{dest}\PYG{p}{.}\PYG{n}{y}\PYG{o}{=}\PYG{n}{c}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n}{source}\PYG{p}{.}\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{=}\PYG{n}{w}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{n}{source}\PYG{p}{.}\PYG{n}{h}\PYG{o}{=}\PYG{n}{h}\PYG{p}{;}
    \PYG{k}{switch} \PYG{p}{(}\PYG{n}{text}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{1}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{2}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{3}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{4}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{5}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{6}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{7}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{7}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{8}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{9}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{n}{source}\PYG{p}{.}\PYG{n}{w}\PYG{o}{*}\PYG{l+m+mi}{9}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
      \PYG{k}{case} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{o}{:} \PYG{n}{source}\PYG{p}{.}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{SDL\PYGZus{}RenderCopy}\PYG{p}{(}\PYG{n}{renderer}\PYG{p}{,}\PYG{n}{tDigits}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{source}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{dest}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Level Structure and Level Editor}
\label{\detokenize{level:level-structure-and-level-editor}}\label{\detokenize{level::doc}}
All datas which a level contains stored at a structure called \sphinxcode{\sphinxupquote{Level}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct}\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{width}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{height}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{diamondsRequired}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{time}\PYG{p}{;}
  \PYG{k+kt}{double} \PYG{n}{waterRate}\PYG{p}{;}
  \PYG{n}{Point} \PYG{n}{playerStartPos}\PYG{p}{;}
  \PYG{n}{Point} \PYG{n}{doorPos}\PYG{p}{;}
  \PYG{n}{Block} \PYG{o}{*}\PYG{o}{*} \PYG{n}{blocks}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{n}{Level}\PYG{p}{;}
\end{sphinxVerbatim}

For saving this, i use fwrite and write them to a bin file. For create a new level
or edit an existing one, i created a level editor.


\subsection{Guide to Level Editor}
\label{\detokenize{level:guide-to-level-editor}}
\begin{DUlineblock}{0em}
\item[] If you want to create a new level, answer first question with n.
\item[] Enter the sizes you want and than a window will pop up.
\item[] 
\item[] If you want to edit an existing level, answer y. Enter the file name without \sphinxstyleemphasis{.bin}
\item[] extension and than a window will pop up.
\item[] 
\item[] It works like ms paint. You pick a brush from bottom than paint.
\item[] After you done your work press save, anything won’t on this window, check the terminal.
\item[] Enter how many diamond is required for pass the level.
\item[] Enter how much time do player got.
\item[] Enter water spread rate, if you enter x it means water will spread every x second.
\item[] Enter the file name you want to save as. (Don’t add extension).
\end{DUlineblock}

\begin{sphinxadmonition}{note}{Note:}
The values in parentheses shows previous value for editing existing level.
Game only recognize the levels named \sphinxstylestrong{level{[}1-10{]}.bin}.
\end{sphinxadmonition}



\renewcommand{\indexname}{Index}
\printindex
\end{document}